\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{cmbright}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{geometry}
\usepackage{array}
\usepackage{longtable}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{hyperref}

\geometry{margin=2cm}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt}

\begin{document}

\begin{center}
\Large\textbf{Как дебагать и не какать}
\end{center}

Этот файлик для региона, в будущем сделаю его и для всероса, добавлю интерактивки, двойной запуск и открытые тесты. WL Лёха

\section*{Общая информация}

\textbf{Основные выводы из памятки участника регионального этапа:}

\begin{itemize}
\item у вас всего 50 попыток на одну задачу, 200 суммарно по всем задачам. Раньше было ограничение 150 попыток суммарно;
\item берется лучшее решение (склейки нету, если первое решение заходит на одну подгруппу, а второе на другую, то заифайте и объедините решения);
\item из системы нельзя выгружать посылки, поэтому сохраняйте все решения (например, название файла - номер посылки в системе);
\item в задачах возможна потестовая оценка.
\end{itemize}

\section*{Не заходит по PE (presentation error)}

PE на реге 21 веке. Что за кринж? Да, на регионе может быть PE, но это не значит, что если вы выведете в неправильном формате, то у вас будет PE, может и WA.

В памятке участника как пример возникновения PE: ``Программа должна вывести числа в одной строке через пробел, а вывела их в разных строках или наоборот``. Современные чекеры не будут ругаться на такие случаи, но все же выводите ответ, как просит задача.

Бывает два вида чекеров (проверяющих ответ участника программ):

\begin{itemize}
\item \textbf{Стандартный} (проверяет, равен ли ответ участника ответу жюри). В таком случае PE можно получить только если выводить совсем не то, например строку вместо числа.
\item \textbf{Кастомный} (когда верных ответов несколько и нельзя просто сверять с ответом жюри). В таком случае PE совсем нельзя получить, всегда будете получать WA.
\end{itemize}

В целом нужно воспринимать PE как WA, скорее всего оно не имеет смысла.

\section*{Не заходит по WA (wrong answer)}

\begin{itemize}
\item Забыли убрать отладочный вывод.
\item Когда используете double, может вывести nan или inf (возможно выведет, как PE).
\item Переполнение int.
\item Undefined behavior (поведение зависит от компилятора, бывает, например, при выходе за границы стат. массива).
\item Неверная идея или баг в коде (ну тут мои полномочия всё).
\end{itemize}

\section*{Не заходит по TL (time limit)}

На полигоне (g++ 14) одна секунда - это 2е9 ifов (потому что прагма O2 автоматически включена на CF), 2e8 операций деления и 5е8 операций остатка. На моем компьютере (g++ 17) одна секунда - это 7e8 операций сложения, 3e8 операций деления, 5e8 ifов, 4e8 остатка. И появляется резонный вопрос, чему равна одна секунда в c++? Невозможно понять из-за константы операций, однако я думаю безопасно считать, что это примерно от 1e8 до 3e8 действий, вы сможете сделать больше если захотите.

Однако создатели задач региона и всероса очень редко планируют, чтобы вы их запихивали (либо дают за это мало баллов). Поэтому:

\bigskip

\begin{longtable}{|>{\raggedright}p{3cm}|p{5cm}|p{5cm}|}
\hline
Ограничения по n & Авторская асимптотика & Вы можете упихать (я в вас верю >-< ) \\
\hline
до 10 & $O(n \cdot n!)$ & $O(n^2 \cdot n!)$ или $O(n^8)$ \\
\hline
до 15-18 & $O(3^n)$ & $O(3^n)$ \\
\hline
до 20 & $O(2^n)$ или $O(2^n \cdot n)$ & $O(2^n \cdot n^2)$ \\
\hline
до 40-50 (MITM) & $O(2^{\frac{n}{2}})$ или $O(2^{\frac{n}{2}} \cdot n)$ & То же самое, но с большой константой \\
\hline
до 1000 & $O(n^2)$ или $O(n^2 \cdot \log n)$ & $O(n^2 \cdot \log^2 n)$ \\
\hline
до 1e5 & $O(n)$, $O(n \cdot log(n))$, $O(n \cdot \log^2 n)$ или $O(n \cdot \sqrt{n})$ & $O(С \cdot n \cdot \log^2 n)$ или $O(С \cdot n \cdot \sqrt{n})$, где С=10 \\
\hline
до 3e5 & То же самое, но без $O(n \cdot \log^2 n)$ & То же самое, только С меньше C=3 \\
\hline
до 1e6 & $O(n)$, $O(n \cdot \log n)$ & $O(C \cdot n \cdot \log n)$, C=5 \\
\hline
\end{longtable}

Не забывайте, что у вас может появиться бесконечный цикл. Тут ускорения не помогут :)

``Программа ждет ввода данных, хотя входной поток уже закончился'' - памятка участника. Не думаю, что это у вас будет)

\textbf{Ускорение потоков ввода и вывода}

Решения были запущены на одном и том же коде, вводящем 1e5 чисел и выводящем их, с добавлением (ios\_base::sync\_with\_stdio(0), cin.tie(0) или cout.tie(0))

Видно, что cout.tie(0) бесполезно. ВЫУЧИТЕ другие два ускорения, ведь они в 3 раза улучшают время, и не каждая среда может подсказать.

Правильно расставляйте типы переменных, т. к. int занимает меньше времени на создание.

Сделать статические массивы вместо векторов. При этом в местах, где vector всё же используется как стек, перед использованием сделать v.reserve(MAXN).

Заменить map и set на unordered\_map и unordered\_set. Не забудьте сделать mp.reserve(MAXN), иначе будет долго работать!

Бывают ситуации, когда нужно ключом unordered\_map сделать структуру. Для этого нужно структуру захешировать и записывать в unordered\_map хэш.

\textbf{Прагмы}

Стандартный набор, который я использую во всех решениях:

\begin{verbatim}
#pragma GCC optimize("O3,unroll-loops")

// #pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt")
\end{verbatim}

Заметим, что вторая строка закомментирована. Если не заходит без неё, можно попробовать её раскомментировать и заслать. Но по умолчанию отправляйте без неё.

Почитать, за что каждая из них отвечает:  
\url{https://codeforces.com/blog/entry/129283?locale=ru}.

Пытаться загнать прагмы только тогда, когда вам нечего больше делать!

По возможности избавляться от любых делений и остатков по модулю. Например, взятие остатка по модулю, когда пишешь хэш, работает дольше, чем if сумма больше модуля.

Путем проб и ошибок стало понятно, что переписывать решение в тернарные операторы для ускорения по времени бессмысленно.

Переход по столбцам а потом по строкам в массиве (j, i) работает дольше, чем по строкам, а потом по столбцам (i, j, стандартный обход), из-за прыжков по памяти длиной n, вместо 1.

\section*{Не заходит по ML (Memory limit)}

256 мб - это примерно 6e7 int и в 2 раза меньше long long и double.

Правильно расставляйте типы переменных, int занимает в 2 раза меньше бит, чем long long.

Большая рекурсия, возможно стоит попытаться заменить на циклы или передавать меньше параметров.

``Ошибки при работе с указателями в C/C++ также могут диагностироваться, как ML'' - памятка участника (Устарело, бывает в старых плюсах).

Unordered\_map, unordered\_set стоит заменить на map, set.

Добавить к vector, unordered\_map или unordered\_set после момента их создания .reserve(MAXN).

\section*{Не заходит по RE (Runtime error)}

RE может быть не видно на вашем компьютере, это называется UB (Undefined Behavior).

\#define \_GLIBCXX\_DEBUG — отлавливает все RE в STL-структурах. Если получили RE на 1 тесте, а локально всё правильно, надо написать это в начало кода (до includов). Также стоить заметить, что эта дебаг может делать TL, поэтому используйте его только локально (\#ifdef LOCAL).

Превышение лимита по памяти также может диагностироваться, как ``Ошибка выполнения'' - памятка участника. (Устарело, возможно только на informatics.)

\begin{itemize}
\item Выход за пределы массива.
\item Деление на 0 (причем в double и long double не возникает RE,   компилятор выведет inf).
\item Разыменовывание указателя на end в векторах и сетах.
\item Забыли убрать assert, с помощью него можно удобно дебагать и ifать тест.
\end{itemize}

\section*{Немного мудрости от ваших любимых тренеров Москвы}

Набирайте частички, не в OKах счастье:)

Не тратьте много времени на одной задаче, придумайте для себя стратегию, которая не зависит от сложности задач или аномальных задач (С2 на рюкзак 2025 года).

Я (Лёха) решал в порядке DABC на то кол-во баллов, что мог, тратил не больше 20 минут на дебаг или размышления о задаче (чтение задачи и написание кода сюда не входит). Если понимал, что 20 минут прошли, то я переходил к следующей задаче по циклу. А в последний час оценивал ситуацию и решал, что мне лучше делать, чтобы набрать как можно больше баллов.

Можно сначала решить D и C на халявные подгруппы, а потом уже решать A и B на большие баллы. Так не надо будет беспокоиться о том, что остался 0 по D.

\section*{Хороший рандом}

\begin{verbatim}
mt19937 rng(73);

uniform_int_distribution<int> uid(0, int(1e9));
int rnd(int n) {	   // случайное целое число от 0 до n - 1 включительно
    return uid(rng) % n;  // если берете всегда по одному и тому же модулю, лучше uid создать от этого модуля, тем самым не брать остаток
}
 
ld rndd() {    // случайное вещественное число от 0 до 1
    return ld(rand()) / RAND_MAX;
}

vector <int> v;
shuffle(v.begin(), v.end(), rng); // перемешать все числа
\end{verbatim}

Сводите задачи к более мелким и решайте их по отдельности.

Если вы пишете ДО, геому или любой другой алгоритм, создавайте удобную структуру или шаблон, который вы умеете по памяти безошибочно писать, чтобы не тратить много время на дебаг уже известного алгоритма.

Сppreference поможет, если забыли, как что-то работает. Попробуйте им пользоваться дома и на пробном туре.

\section*{Если идеи не приходят}

Если в условии дан граф, иногда бывает полезно запускать DFS от случайной вершины и сделать shuffle списков смежности. Это иногда позволяет немного уменьшить время работы (т.к. жюри чаще всего делает тесты под запуск от корня 1).

То же самое можно сказать про любую задачу, где структуру входных данных можно сделать более случайной.

Бывает полезно взять очень много жадников и рандомных решений и вывести наилучший из ответов, которые они получили.

Можно группы с маленьким n ифать и запускать на них переборное решение, а на больших группах запускать идею из 5 пункта.

\bigskip
\textbf{ОЧЕНЬ ВАЖНО, покакать перед туром, чтобы не обосраться на нем. У тебя всё получится, мы верим в тебя =)}

\bigskip

Спасибо Антону Ныйкину, Антону Барисову, Марку Семенову, Тимуру Лузгову и всем прочитавшим файлик за помощь в его создании.

\end{document}
